package main

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/nvcnvn/flows"
)

type Server struct {
	pool     *pgxpool.Pool
	tenantID uuid.UUID
}

// POST /api/loans/applications
func (s *Server) StartLoanApplication(w http.ResponseWriter, r *http.Request) {
	var input LoanApplicationInput
	if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Set tenant context
	ctx := flows.WithTenantID(context.Background(), s.tenantID)

	// Start workflow
	exec, err := flows.Start(ctx, LoanApplicationWorkflow, &input)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to start workflow: %v", err),
			http.StatusInternalServerError)
		return
	}

	// Return workflow ID immediately (async processing)
	response := map[string]string{
		"workflow_id": exec.WorkflowID().String(),
		"status":      "processing",
		"message":     "Loan application submitted successfully",
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)

	fmt.Printf("[API] Started loan application workflow: %s\n", exec.WorkflowID())
}

// GET /api/loans/applications/:workflow_id
func (s *Server) GetLoanApplicationStatus(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	workflowIDStr := vars["workflow_id"]

	workflowID, err := uuid.Parse(workflowIDStr)
	if err != nil {
		http.Error(w, "Invalid workflow ID", http.StatusBadRequest)
		return
	}

	// Query workflow status
	ctx := flows.WithTenantID(context.Background(), s.tenantID)
	status, err := flows.Query(ctx, workflowID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to query workflow: %v", err),
			http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(status)

	fmt.Printf("[API] Queried workflow status: %s - %s\n", workflowID, status.Status)
}

// POST /api/loans/applications/:workflow_id/manager-approval
func (s *Server) SubmitManagerApproval(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	workflowIDStr := vars["workflow_id"]

	workflowID, err := uuid.Parse(workflowIDStr)
	if err != nil {
		http.Error(w, "Invalid workflow ID", http.StatusBadRequest)
		return
	}

	var signal ManagerApprovalSignal
	if err := json.NewDecoder(r.Body).Decode(&signal); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Send signal to workflow
	ctx := flows.WithTenantID(context.Background(), s.tenantID)
	err = flows.SendSignal(ctx, workflowID, "manager-approval", &signal)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to send signal: %v", err),
			http.StatusInternalServerError)
		return
	}

	response := map[string]string{
		"workflow_id": workflowID.String(),
		"status":      "signal_sent",
		"message":     "Manager decision recorded successfully",
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)

	fmt.Printf("[API] Manager approval signal sent: %s - approved=%v\n",
		workflowID, signal.Approved)
}

// GET /api/loans/applications/:workflow_id/result
func (s *Server) GetLoanApplicationResult(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	workflowIDStr := vars["workflow_id"]

	workflowID, err := uuid.Parse(workflowIDStr)
	if err != nil {
		http.Error(w, "Invalid workflow ID", http.StatusBadRequest)
		return
	}

	// Create execution handle
	ctx := flows.WithTenantID(context.Background(), s.tenantID)

	// This is a trick: we need to recreate the execution handle
	// In a real app, you'd store this or query differently
	store := flows.NewEngine(s.pool).Store()
	exec := &flows.Execution[LoanApplicationOutput]{
		// Note: This is simplified - in production you'd need proper exec handle management
	}

	// Get result (waits if not complete)
	timeoutCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	result, err := exec.Get(timeoutCtx)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to get result: %v", err),
			http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}

func main() {
	// Database connection
	pool, err := pgxpool.New(context.Background(),
		"postgres://postgres:postgres@localhost:5433/loans?sslmode=disable")
	if err != nil {
		panic(err)
	}
	defer pool.Close()

	// Initialize engine
	engine := flows.NewEngine(pool)
	flows.SetEngine(engine)

	// Create tenant (in production, this comes from auth)
	tenantID := uuid.New()

	// Start worker
	worker := flows.NewWorker(pool, flows.WorkerConfig{
		Concurrency:   5,
		WorkflowNames: []string{"loan-application-workflow"},
		PollInterval:  500 * time.Millisecond,
		TenantID:      tenantID,
	})
	defer worker.Stop()

	go func() {
		if err := worker.Run(context.Background()); err != nil {
			fmt.Printf("Worker error: %v\n", err)
		}
	}()

	// Setup HTTP server
	server := &Server{
		pool:     pool,
		tenantID: tenantID,
	}

	router := mux.NewRouter()
	router.HandleFunc("/api/loans/applications", server.StartLoanApplication).Methods("POST")
	router.HandleFunc("/api/loans/applications/{workflow_id}",
		server.GetLoanApplicationStatus).Methods("GET")
	router.HandleFunc("/api/loans/applications/{workflow_id}/manager-approval",
		server.SubmitManagerApproval).Methods("POST")
	router.HandleFunc("/api/loans/applications/{workflow_id}/result",
		server.GetLoanApplicationResult).Methods("GET")

	fmt.Println("üöÄ Loan Application Service started on :8080")
	fmt.Printf("   Tenant ID: %s\n", tenantID)
	fmt.Println("\nüìù Example API calls:")
	fmt.Println("   curl -X POST http://localhost:8080/api/loans/applications \\")
	fmt.Println("     -H 'Content-Type: application/json' \\")
	fmt.Println("     -d '{\"applicant_id\":\"APP123\",\"amount\":250000,\"purpose\":\"home\",\"credit_score\":720}'")
	fmt.Println()

	http.ListenAndServe(":8080", router)
}
